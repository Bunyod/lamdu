{-# LANGUAGE LambdaCase, NoImplicitPrelude, OverloadedStrings #-}
module Lamdu.GUI.ExpressionEdit.HoleEdit.ValTerms
    ( expr
    , allowedSearchTermCommon
    , allowedFragmentSearchTerm
    , getSearchStringRemainder
    ) where

import qualified Control.Lens as Lens
import qualified Data.Char as Char
import qualified Data.Text as Text
import qualified GUI.Momentu.Widgets.Menu.Search as SearchMenu
import qualified Lamdu.Builtins.Anchors as Builtins
import qualified Lamdu.CharClassification as Chars
import           Lamdu.Formatting (Format(..))
import           Lamdu.GUI.ExpressionGui (ExpressionN)
import           Lamdu.Name (Name(..), Collision(..))
import qualified Lamdu.Name as Name
import qualified Lamdu.Sugar.Lens as SugarLens
import qualified Lamdu.Sugar.Names.Get as NamesGet
import qualified Lamdu.Sugar.Types as Sugar
import           Revision.Deltum.Property (Property)
import qualified Revision.Deltum.Property as Property
import           Revision.Deltum.Transaction (Transaction)

import           Lamdu.Prelude

type T = Transaction

collisionText :: Name.Collision -> Text
collisionText NoCollision = ""
collisionText (Collision i) = Text.pack (show i)
collisionText UnknownCollision = "?"

ofName :: Name.Form -> Text
ofName (Name.AutoGenerated text) = text
ofName (Name.Unnamed collision) = Name.unnamedText <> collisionText collision
ofName (Name.Stored name collision) = name <> collisionText collision

formatProp :: Format a => Property m a -> Text
formatProp i = i ^. Property.pVal & format

formatLiteral :: Sugar.Literal (Property m) -> Text
formatLiteral (Sugar.LiteralNum i) = formatProp i
formatLiteral (Sugar.LiteralText i) = formatProp i
formatLiteral (Sugar.LiteralBytes i) = formatProp i

nameText :: Name m -> Text
nameText name = name ^. Name.form & ofName

bodyShape :: Sugar.Body (Name m) m expr -> [Text]
bodyShape = \case
    Sugar.BodyLam {} -> ["lambda", "\\", "Λ", "λ", "->", "→"]
    Sugar.BodySimpleApply {} -> ["Apply"]
    Sugar.BodyLabeledApply {} -> ["Apply"]
    Sugar.BodyRecord {} -> ["{}", "()", "[]"]
    Sugar.BodyGetField gf -> ["." <> nameText (gf ^. Sugar.gfTag . Sugar.tagName)]
    Sugar.BodyCase cas ->
        ["case", "of"] ++
        case cas of
            Sugar.Case Sugar.LambdaCase (Sugar.Composite [] Sugar.ClosedComposite{} _) -> ["absurd"]
            _ -> []
    Sugar.BodyIfElse {} -> ["if", ":"]
    Sugar.BodyInject (Sugar.Inject tag _) ->
        (nameText (tag ^. Sugar.tagName) <>) <$> [":", "."]
    Sugar.BodyLiteral i -> [formatLiteral i]
    Sugar.BodyGetVar Sugar.GetParamsRecord {} -> ["Params"]
    Sugar.BodyGetVar {} -> []
    Sugar.BodyToNom {} -> []
    Sugar.BodyFromNom nom
        | nom ^. Sugar.nTId . Sugar.tidTId == Builtins.boolTid -> ["if"]
        | otherwise -> []
    Sugar.BodyHole {} -> []
    Sugar.BodyFragment {} -> []
    Sugar.BodyPlaceHolder {} -> []

bodyNames :: Monad m => Sugar.Body (Name (T m)) (T m) expr -> [Text]
bodyNames =
    \case
    Sugar.BodyGetVar Sugar.GetParamsRecord {} -> []
    Sugar.BodyLam {} -> []
    b -> NamesGet.fromBody b <&> (^. Name.form) <&> ofName

expr :: Monad m => ExpressionN m a -> [Text]
expr (Sugar.Expression body _) =
    bodyShape body <>
    bodyNames body <>
    case body of
    Sugar.BodyToNom (Sugar.Nominal _ binder) ->
        expr (binder ^. Sugar.bbContent . SugarLens.binderContentExpr)
    Sugar.BodyFromNom (Sugar.Nominal _ val) -> expr val
    _ -> []

type Suffix = Char

allowedSearchTermCommon :: [Suffix] -> Text -> Bool
allowedSearchTermCommon suffixes searchTerm =
    any (searchTerm &)
    [ Text.all (`elem` Chars.operator)
    , Text.all Char.isAlphaNum
    , (`Text.isPrefixOf` "{}")
    , (== "\\")
    , Lens.has (Lens.reversed . Lens._Cons . Lens.filtered inj)
    ]
    where
        inj (lastChar, revInit) =
            lastChar `elem` suffixes && Text.all Char.isAlphaNum revInit

allowedFragmentSearchTerm :: Text -> Bool
allowedFragmentSearchTerm searchTerm =
    allowedSearchTermCommon ":" searchTerm || isGetField searchTerm
    where
        isGetField t =
            case Text.uncons t of
            Just (c, rest) -> c == '.' && Text.all Char.isAlphaNum rest
            Nothing -> False

-- | Given a hole result sugared expression, determine which part of
-- the search term is a remainder and which belongs inside the hole
-- result expr
getSearchStringRemainder :: SearchMenu.ResultsContext -> Sugar.Expression name m a -> Text
getSearchStringRemainder ctx holeResultConverted
    | isA Sugar._BodyInject = ""
    | isSuffixed ":" = ":"
    | isSuffixed "." = "."
    | otherwise = ""
    where
        isSuffixed suffix = Text.isSuffixOf suffix (ctx ^. SearchMenu.rSearchTerm)
        fragmentExpr = Sugar.rBody . Sugar._BodyFragment . Sugar.fExpr
        isA x = any (`Lens.has` holeResultConverted) [Sugar.rBody . x, fragmentExpr . Sugar.rBody . x]
