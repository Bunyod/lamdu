{-# LANGUAGE NoImplicitPrelude, TemplateHaskell, OverloadedStrings #-}
module Lamdu.Sugar.Names.Types
    ( Stored
    , Collision(..), _NoCollision, _Collision
    , visible
    , unnamedText
    , Form(..), _AutoGenerated, _Unnamed, _Stored
    , Name(..), form, setName
    , ExpressionN, BodyN, DefinitionN
    ) where

import qualified Control.Lens as Lens
import           Data.Store.Transaction (Transaction)
import           Lamdu.Sugar.Types (Expression, Body, Definition)

import           Lamdu.Prelude

type T = Transaction
type Stored = Text

data Collision
    = NoCollision
    | Collision {-Disambiguator:-} Int
    | UnknownCollision -- we have a collision but unknown suffix (inside hole result)
    deriving (Show)

data Form
    = AutoGenerated Text
    | Unnamed Collision
    | Stored Text Collision
    deriving (Show)

unnamedText :: Text
unnamedText = "Unnamed"

visible :: Form -> (Text, Collision)
visible (Unnamed suffix) = (unnamedText, suffix)
visible (Stored name suffix) = (name, suffix)
visible (AutoGenerated name) = (name, NoCollision)

data Name m = Name
    { _form :: Form
    , _setName :: Text -> m ()
    }

Lens.makeLenses ''Name
Lens.makePrisms ''Collision
Lens.makePrisms ''Form

instance Show (Name m) where
    show name = concat [ "(Name ", show (name ^. form), " ", ")" ]

type ExpressionN m a = Expression (Name (T m)) (T m) a
type BodyN m a = Body (Name (T m)) (T m) (ExpressionN m a)
type DefinitionN m a = Definition (Name (T m)) (T m) (ExpressionN m a)
